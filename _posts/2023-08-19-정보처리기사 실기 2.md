---
title:  "정보처리기사 실기 2"
categories: "certificate"
tag: [certificate]
toc: true
---

# 데이터 입 . 출력 구현 1

- 데이터 전환
> - 운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 추출하여 새로 개발할 정보 시스템에서 운영할 수 있도록 변환한 후 적재하는 일련의 과정

- 데이터 검증
> - 원천 시스템의 데이터를 목적 시스템의 데이터로 전환하는 과정이 정상적으로 수행되었는지 여부를 확인하는 과정

- 오류 데이터 측정 및 정제
> - 데이터 품질 분석 -> 오류 데이터 측정 -> 오류 데이터 정제

- 데이터베이스
> - 여러 사람에 의해 공동으로 사용될 데이터를 중복을 배제하여 통합하고, 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터
> - 데이터베이스 정의
>   - 통합된 데이터 - 자료의 중복을 배제한 데이터의 모임
>   - 저장된 데이터 - 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
>   - 운영 데이터 - 조직의 고유한 업무에 수행하는 데 반드시 필요한 자료
>   - 공용 데이터 - 여러 응용 시스템들이 공통으로 소유하고 유지하는 자료

- DBMS
> - 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어
> - DBMS의 필수 기능 3가지
>   - 정의 기능 - 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
>   - 조작 기능 - 데이터 검색, 갱신, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능
>   - 제어 기능 - 데이터의 무결성, 보안, 권한, 검사, 병행 제어를 제공하는 기능

- 스키마
> - 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것
> - 외부 스키마 - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
> - 개념 스키마 - 데이터베이스의 전체적인 논리적 구조, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함
> - 내부 스키마 - 물리적 저장장치의 입장에서 본 데이터베이스 구조, 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

- 데이터베이스 설계 순서
> - 요구 조건 분석 - 요구 조건 명세서 작성
> - 개념적 설계 - 개념 스키마, 트랜잭션 모델링, E-R 모델
> - 논리적 설계 - 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
> - 물리적 설계 - 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
> - 구현 - 목표 DBMS의 DDL로 데이터베이스 생성, 트랜잭션 작성

- 개념적 설계
> - 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정

- 논리적 설계
> - 현실 세계에서 발생하는 자료를 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정

- 물리적 설계
> - 논리적 설계에서 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정

- 데이터 모델
> - 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모델
> - 데이터 모델에 표시할 요소
>   - 구조 - 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현
>   - 연산 - 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
>   - 제약 조건 - 데이터베이스에 저장할 수 있는 실제 데이터의 논리적인 제약 조건

- 개체
> - 데이터베이스에 표현하려는 것, 사람이 생각하는 갠며이나 정보 단위 같은 현실 세계의 대상체

- 관계
> - 개체와 개체 사이의 논리적인 연결
> - 관계의 형태 - 1:1, 1:N, N:M

- E-R 모델
> - 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세게의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법, 피터 첸이 제안

- E-R 다이어그램
> - 사각형 - 개체 타입
> - 마름모 - 관계 타입
> - 타원 - 속성
> - 이중 타원 - 다중값 속성(복합 속성)
> - 밑줄 타원 - 기본키 속성
> - 복수 타원 - 복합 속성
> - 관계 - 관계에 대한 대응수 선 위에 기술
> - 선, 링크 - 개체 타입과 속성을 연결

- 관계형 데이터베이스의 릴레이션 구조
> - 릴레이션은 데이터들을 표의 형태로 표현한 것, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성

- 튜플
> - 릴레이션을 구성하는 각각의 행, 속성의 모임, 파일 구조의 레코드, 튜플의 수를 카디널리티 또는 기수, 대응수라고 함

- 속성
> - 데이터베이스를 구성하는 가장 작은 논리적 단위, 파일 구조의 데이터 항목 또는 데이터 필드, 개체의 특성을 기술, 속성의 수를 디그리 또는 차수라고 함

- 도메인
> - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합

- 후보키
> - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
> - 유일성 - 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
> - 최소성 - 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 함

- 기본키
> - 후보키 중에서 특별히 선정된 주키

- 대체키
> - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키

- 슈퍼키
> - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키

- 외래키
> - 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

- 무결성
> - 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성

- 관계대수
> - 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어

- 순수 관계 연산자
> - Select - 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
> - Project - 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
> - Join - 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
> - Division - X > Y 인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

- 일반 집합 연산자
> - 합집합 - 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산
> - 교집합 - 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
> - 차집합 - 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
> - 교차곱 - 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산

- 관계해석
> - 관계 데이터의 연산을 표현하는 방법
> - 관계 데이터 모델의 제안자인 코드가 술어 해석에 기반을 두고 제안

- 이상
> - 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상
> - 삽입 이상 - 테이블에 데이터를 삽입 할 때 의도와는 상관없는 원하지 않는 값들로 인해 삽입할 수 없게 되는 현상
> - 삭제 이상 - 테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상
> - 갱신 이상 - 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상

- 함수적 종속
> - 어떤 테이블 R, X와 Y는 R의 속성 집합의 부분 집합, 속성 X의 값에 대해 속성 Y값이 하나만 연관되어 있을 때 X -> Y 이다.
>   - X -> Y = Y는 X에 함수적으로 종속함. = X가 Y를 함수적으로 결정함.
> - 완전 함수적 종속 - 어떤 테이블 R, 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속, 속성 집합 X의 임의 부분 집합 Z에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속
> - 부분 함수적 종속 - 어떤 테이블 R, 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속, 속성 집합 X의 임의 부분 집합 Z에 대해 함수적 종속일 때 속성 Y는 속성 집합 X에 부분 함수적 종속

- 정규화
> - 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정
> - 가능한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것
> - 1NF, 2NF, 3NF, BCNF, 4NF, 5NF

- 정규화 과정

- 정규화 과정 정리
> - 비정규 릴레이션 - 도메인이 원자값
> - 1NF -> 부분적 함수 종속 제거 -> 2NF -> 이행적 함수 종속 제거 -> 3NF -> 결정자이면서 후보자가 아닌 것 제거 -> BCNF -> 다치 종속 제거 -> 4NF -> 조인 종속성 이용 -> 5NF

- 반정규화
> - 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위
> - 시스템의 성능이 향상되고 관리 효율성 증가, 데이터의 일관성 및 정합성 저하 될 수 있음, 과도한 반 정규화는 성능을 저하시킬 수 있음

- 중복 테이블 추가
> - 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것
> - 중복 테이블 추가 방법
>   - 집계 테이블의 추가 - 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것
>   - 진행 테이블의 추가 - 이력 관리 등의 목적으로 추가하는 테이블
>   - 특정 부분만을 포함하는 테이블의 추가 - 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성

- 시스템 카탈로그
> - 시스템에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
> - 좁은 의미로 데이터 사전이라 함

- 트랙잭션
> - 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업 단위 또는 한꺼번에 모두 수행되어야 할 일련의 활동

- 트랜잭션의 특성
> - 원자성 - 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료되든지 아니면 전혀 반영되지 않도록 복구되어야 함
> - 일관성 - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
> - 독립성, 격리성, 순차성 - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음 
> - 영속성, 지속성 - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

- CRUD 분석
> - 프로세스의 테이블 간에 CRUD 매트리스를 만들어서 트랜잭션을 분석하는 것
> - Create, Read, Update, Delete

- 인덱스
> - 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조

- 클러스터드/넌클러스터드 인덱스
> - 클러스터드 인덱스 - 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
> - 넌클러스터드 인덱스 - 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식

# 데이터 . 입출력 구현 2

- 뷰
> - 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블

- 파티션
> - 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것

- 파티션의 종류
> - 범위 분할 - 지정한 열의 값을 기준으로 분할함
> - 해시 분할 - 해시 함수를 적용한 결과 값에 따라 데이터를 분할함
> - 조합 분할 - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식

- 분산 데이터베이스의 목표
> - 위치 투명성 - 엑세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음
> - 중복 투명성 - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행함
> - 병행 투명성 - 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
> - 장애 투명성 - 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리함

- RTO/RPO
> - RTO(목표 복구 시간) - 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미함
> - RPO(목표 복구 시점) - 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미함

- 암호화
> - 암호화 과정 - 암호화되지 않은 평문을 암호문으로 바꾸는 과정
> - 복호화 과정 - 암호문을 원래의 평문으로 바꾸는 과정
> - 암호화 기법 - 개인키 암호 방식, 공개키 암호 방식

- 임의 접근통제
> - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식

- 강제 접근 통제
> - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식

- 역할기반 접근통제
> - 사용자의 역할에 따라 접근 권한을 부여하는 방식

- 스토리지
> - 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술
> - DAS, NAS, SAN

- DAS
> - 서버와 저장장치를 전용 케이블로 직접 연결하는 방식

- NAS
> - 서버와 저장장치를 네트워크를 통해 연결하는 방식

- SAN
> - 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식
> - DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식

- 자료 구조
> - 자료를 기억장치의 공간 내에 저장하는 방법과 자료간의 관계, 처리 방법 등을 연구 분석하는 것
> - 자료 구조의 분류
>   - 선형 구조 - 배열, 선형 리스트(연속 리스트, 연결 리스트), 스택, 큐, 데크
>   - 비선형 구조 - 트리, 그래프

- 배열
> - 크기와 형이 동일한 자료들이 순서대로 나열된 자료의 집합

- 스택
> - 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조

- 큐
> - 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 작업이 이루어지는 자료 구조

- 그래프
> - 정점과 간선의 두 집합으로 이루어지는 자료 구조

- 방향/무방향 그래프의 최대 간선 수
> - 방향 그래프의 최대 간선 수 - n(n-1)
> - 무방향 그래프의 최대 간선 수 - n(n-1)/2

- 트리
> - 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태

- 트리 관련 용어
> - 노드 - 트리의 기본 요소, 자료 항목과 다른 항목에 대한 가지를 합친 것
> - 근 노드 - 트리의 맨 위에 있는 노드
> - 디그리 - 각 노드에서 뻗어나온 가지의 수
> - 단말 노드 - 자식이 하나도 없는 노드, 디그리가 0인 노드
> - Level - 근 노드의 Level을 1로 가정, 어떤 Level이 L이면 자식 노드는 L+1
> - 깊이 - 트리에서 노드가 가질 수 있는 최대의 레벨
> - 숲 - 여러 개의 트리가 모여 있는 것
> - 트리의 디그리 - 노드들의 디그리 중에서 가장 많은 수

- Preorder 운행법
> - 이진 트리를 Root -> Left -> Right 순으로 운행하며 노드들을 찾아가는 방법

- Inorder 운행법
> - 이진 트리를 Left -> Root -> Right 순으로 운행하며 노드들을 찾아가는 방법

- Postorder 운행법
> - 이진 트리를 Left -> Right -> Root  순으로 운행하며 노드들을 찾아가는 방법

- Infix 표기를 Prefix로 바꾸기
> - Infix로 표기된 수식에서 연산자를 해당 피연산자 2개의 앞(왼쪽)에 오도록 이동하면 Prefix가 됨
> - X = A / B * ( C + D ) + E => X + * / A B + C D E

- Infix 표기를 Postfix로 바꾸기
> - Postfix로 표기된 수식에서 연산자를 해당 피연산자 2개의 뒤(오른쪽)에 오도록 이동하면 Postfix가 됨
> - X = A / B * ( C + D ) + E => X A B / C D + * E + =

- Postfix 표기를 Infix로 바꾸기
> - Infix 표기법에서 연산자를 해당 피연산자가 2개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 2개의 가운데로 옮기면 됨
> - A B C - / D E F + * + => A / ( B - C ) + D * ( E + F )

- 삽입 정렬
> - 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식
> - 평균, 최악 시간 복잡도 O(n²)

- 선택 정렬
> - n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
> - 평균, 최악 시간 복잡도 O(n²)

- 버블 정렬
> - 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
> - 평균, 최악 시간 복잡도 O(n²)

- 퀵 정렬
> - 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복하는 정렬 방식
> - 평균 시간 복잡도 O(nlog₂n), 최악 시간 복잡도 O(n²)

- 힙 정렬
> - 전이진 트리를 이용한 정렬 방식
> - 평균, 최악 시간 복잡도 O(n²)

- 2-Way 합병 정렬
> - 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식
> - 평균, 최악 시간 복잡도 O(nlog₂n)